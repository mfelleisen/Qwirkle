#! /bin/sh
#| -*- racket -*-
exec racket -tm "$0" -- ${1+"$@"}
|#
#lang racket

;; create the README.md files from README.source in the top-level & all git-tracked code directories:
;; (assume the directories contain only files) 

(define EXCEPTIONS '[".git" "compiled" "README.md" "README.source" "scribblings"]) 

#; {type Ordering = [Listof [directory:String ∪ [Cons directory:String [Listof file:String]]]]}
;; the `file` name is assumed to be a ".rkt" file (for now)

(define ORDER ; Ordering 
  '[ ["Referee" "referee" "ref-state"]
     "Run"
     ["Server" "server"]
     "Client"
     ["Player" "mechanics" "strategies"]
     ["Common"
      "player-interface"
      "placement"
      "q-rule"
      "game-state" "state-of-player"
      "map" "coordinates" "tiles"]])

;; ---------------------------------------------------------------------------------------------------
;; TODO:
;; -- signal missing purpose statements properly
;; -- allow files that don't have a ".rkt" extension 
;; ---------------------------------------------------------------------------------------------------

(define help-string
  #<< eos
 ./xreadme                  ;; shows the generated README.md file                    
 ./xreadme --no             ;; doesn't                                               
 ./xreadme --show directory ;; shows only the README.md in the specified directory
 ./xreadme --show ./        ;; shows only the README.md in the top-level directory   
 ./xreadme --help           ;; show this help string 
 eos
  )

(provide main)

(define (main . x)
  ;; -- analyze cmd line args and directory 
  (define show
    (match x
      [(list)              (eq? (system-type) 'macosx)]
      [(list "--no")       #false]
      [(list "--show" dir) (and (eq? (system-type) 'macosx) (directory-exists? dir) dir)]
      [(list "--help")     (printf "usage:\n~a\n" help-string) (exit 0)]
      [_ (printf "usage: \n~a\n" help-string) (exit 1)]))
  (define adirs (order-via (all-git-tracked directory-exists? EXCEPTIONS) ORDER))
  ;; -- now create the READMEs in `adirs` and link them up 
  (readme* adirs show)
  (top-level-reademe adirs show))

;; ---------------------------------------------------------------------------------------------------
#; {[Listof PathString] Boolean -> Void}
(define (top-level-reademe adirs show)
  (define afils (map (λ (d) (list (build-path d "README.md") d)) adirs))
  (define show2 (and show (or (boolean? show) (equal? show "./"))))
  (write-readme-and-show "directory" afils identity show2))

#; {[Listof PathString] Boolean -> Void}
;; find README.source in each directory in `adirs` and create README.md in this directory
(define (readme* adirs show)
  (for ([dir adirs])
    (define show2 (and show (or (and (boolean? show) show) (and (string? show) (equal? show dir)))))
    (parameterize ([current-directory dir])
      (define afils (order-via (all-git-tracked file-exists? EXCEPTIONS) (find-order dir ORDER)))
      (write-readme-and-show "file" (map (λ (f) (list f f)) afils) strip-semis show2))))

#; {String [Listof [List PathString String]] [String -> String] Boolean -> Void}
;; write one README.md file with an organization table made from `afils` labeled with `header`
;; `clean` each description line with 
(define (write-readme-and-show header afils clean show)
  (define purps (purpose-statements afils clean))
  (copy-file2 "README.source" "README.md" 'delete-existing-one)
  (with-output-to-file "README.md"
    #:exists 'append
    (λ () (printf "~a" (make-table header afils purps))))
  (when show (system "open README.md")))

;; ---------------------------------------------------------------------------------------------------
;; extract purpose statements from code files, note missing purpose statements 

#; {[Listof [List PathString String]] -> [Listof String]}
(define (purpose-statements l clean)
  (for/list ([d l])
    (with-handlers ([exn:fail? (missing-purpose-statement d)])
      (with-input-from-file (first d)
        (λ ()
          (clean (string-trim (caddr (port->lines)))))))))

#; {[List PathString String] -> Empty}
(define ((missing-purpose-statement d) xn)
  (error 'purpose-statement "~a \n~a" (first d) (exn-message xn)))

#; {String -> String}
#; (strip-semis ";; ...") ;; yields "..."
(define (strip-semis l) (substring l 3))

;; ---------------------------------------------------------------------------------------------------
;; interpret readme files to include diagrams 

#; {String[Filename] String[Filename] Any -> Void}
;; copy the content from `old` to `new`
;; replace "@@include(.)" with the content of the specified fle 
(define (copy-file2 old new _)
  (define c-old (file->list old read-line))
  (define c-new (replace "@@include" c-old))
  (with-output-to-file new #:exists 'replace (λ () (for ((l c-new)) (displayln l)))))

#; {String String[Filename] Any -> Void}
(define (replace _ c-old)
  (for/fold ([new '()] #:result (reverse new)) ([line c-old])
    (define m (regexp-match #px"@@include\\((.*)\\)" line))
    (cond
      [(boolean? m) (cons line new)]
      [else
       (define c (reverse (file->list (second m) read-line)))
       (append (code-block c) new)])))

#; {[Listof String] -> [Listof String]}
;; surround given list of strings with ```
(define (code-block c)
  (append (cons "```" c) (list "```")))

;; ---------------------------------------------------------------------------------------------------
;; connect with git and get tracked files and directories 

#; {-> [Listof String]}
(define (all-git-tracked exists? except)
  (define is-tracked? (make-git-tracked exists?))
  (for*/list ([fd (directory-list)]
              [fd-str (in-value (path->string fd))]
              #:when (and (is-tracked? fd-str) (not (member fd-str except))))
    fd-str))

#; {(String -> Boolean) PathString -> PathString -> Boolean}
(define (make-git-tracked exists?) 
  (define untracked (git-untracked))
  (lambda (fd)
    (and (exists? fd)
         (not (regexp-match #px"\\.+compiled" fd))
         (not (member fd untracked)))))

#; {[Path] -> [Listof PathString]}
;; a primitive way to determine Untracked directories and files 
(define (git-untracked)
  (match-define (list in out pid err control) (process "git status"))
  (define status (port->list read-line in))
  (let loop ((status status))
    (cond
      [(empty? status) '()]
      [(regexp-match #px"Untracked" (first status))
       (let inner ([status (cdddr status)])
         (define next (string-trim (first status)))
         (cond
           [(equal? "" next) '()]
           [else (cons next (inner (rest status)))]))]
      [else (loop (rest status))])))

;; ---------------------------------------------------------------------------------------------------
;; ordering

#; {[Listof String] Ordering -> [Listof Striing]}
(define (order-via givens0 order0)
  (let in-order ([order order0] [givens givens0])
    (match order 
      ['() givens]
      [(cons (cons (? string? dir) files) order+)
       (unless (member dir givens0)
         (error 'xreadme "specified name not found: ~a\n in ~s" dir givens0))
       (cons dir (in-order order+ (remove dir givens)))]
      [(cons (? string? dir) order+)
       (unless (member dir givens0)
         (error 'xreadme "specified name not found: ~a\n in ~s" dir givens0))
       (cons dir (in-order order+ (remove dir givens)))])))

#; {dir:String Ordering -> [Listof file:String]}
(define (find-order dir order)
  (match order
    ['() '()]
    [(cons (? string? d) order+)
     (if (equal? d dir) '[] (find-order dir order+))]
    [(cons (cons (? string? d) files) order+)
     (if (equal? d dir) (map (λ (f) (~a f ".rkt")) files) (find-order dir order+))]))

;; ---------------------------------------------------------------------------------------------------
;; MARK DOWN 

#; {String [Listof [List PathString String]] [Listof String] -> String}
(define (make-table header0 adirs purps)
  (define header (make-header header0))
  (define content
    (for/list ([d adirs] [p purps])
      (match-define (list dl dn) d)
      (~a "| [" dn "](" dl ")" " | " p " | \n")))
  (apply string-append header content))

(define (make-header x)
  (string-append
   "\n"
   (string-append "| " x " | purpose |\n")
   "|--------------------- | ------- |\n"))

;; ---------------------------------------------------------------------------------------------------
(module+ test
  (main "--show" "Common"))
